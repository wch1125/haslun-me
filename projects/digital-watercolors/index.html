<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0908">
  <title>Digital Watercolors â€” Haslun Studio</title>
  <meta name="description" content="Watercolor paintings brought to life. An interactive sketchbook by Haslun Studio.">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ¨</text></svg>">
  
  <!-- Early boot: apply pixel mode before first paint to prevent FOUC -->
  <script>
    (function() {
      try {
        // Use namespaced key for multi-app compatibility
        var isPixelMode = localStorage.getItem('haslun:pixelMode') === 'true';
        if (isPixelMode) {
          document.documentElement.classList.add('pixel-mode');
        }
        window.__haslunBoot = { pixelMode: isPixelMode };
      } catch (e) {
        window.__haslunBoot = { pixelMode: false };
      }
    })();
  </script>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=DM+Sans:wght@400;500&family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Stylesheets -->
  <link rel="stylesheet" href="assets/css/base.css">
  <link rel="stylesheet" href="assets/css/loader.css">
  <link rel="stylesheet" href="assets/css/hub-peacocks.css">
  <link rel="stylesheet" href="assets/css/pixel-overlay.css">
</head>
<body>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="loading-content">
      <p class="loading-text">loading...</p>
      <div class="loading-bar">
        <div class="loading-bar-fill" id="loading-fill"></div>
      </div>
    </div>
  </div>

  <!-- Peacock Stage (dreamy wash + blur background) -->
  <div class="peacock-stage" aria-hidden="true">
    <img src="assets/img/peacocks-breathe.gif" alt="" class="peacock-back" decoding="async" />
    <div class="peacock-wash"></div>
    <img src="assets/img/peacocks-breathe.gif" alt="" class="peacock-front" decoding="async" fetchpriority="high" />
  </div>

  <!-- Atmosphere wash overlays -->
  <div class="wash-overlay" id="wash-overlay"></div>
  <div class="transition-wash" id="transition-wash"></div>

  <!-- Docked Menu -->
  <div class="hud" id="hud">
    <button class="hud-button" id="hudToggle" aria-expanded="false" aria-controls="hudPanel">
      <span class="hud-icon">â‰¡</span>
      <span class="hud-label">Menu</span>
      <span class="hud-swatches" aria-hidden="true">
        <i></i><i></i><i></i><i></i><i></i>
      </span>
    </button>

    <div class="hud-panel" id="hudPanel" hidden>
      <header class="hud-brand">
        <div class="hud-title">Digital Watercolors</div>
        <div class="hud-subtitle">Haslun Studio</div>
      </header>

      <nav class="hud-nav">
        <a class="hud-link" href="scenes/">Living Scenes</a>
        <a class="hud-link" href="gallery/">Pixel Sliders</a>
        <a class="hud-link" href="https://haslun.studio/watercolor-lab.html" target="_blank" rel="noopener">Color Lab</a>
        <a class="hud-link" href="https://haslun.studio" target="_blank" rel="noopener">Haslun.studio</a>
      </nav>

      <footer class="hud-footer">
        <span>Â© 2025 Haslun</span>
      </footer>
    </div>
  </div>

  <!-- Welcome trigger (after HUD so CSS sibling selector works) -->
  <button class="welcome-trigger" id="welcomeTrigger" type="button" aria-label="Open menu">
    Welcome!
  </button>

  <!-- MOBILE: Top bar (branding only) -->
  <div class="mobile-topbar">
    <span>Haslun Studio</span>
  </div>

  <!-- MOBILE: Seal button (overlays the painted seal) -->
  <button id="sealMenuBtn" class="seal-menu-btn" aria-label="Open menu" aria-expanded="false">
    <span class="seal-menu-bars" aria-hidden="true">
      <i></i><i></i><i></i>
    </span>
  </button>

  <!-- MOBILE: Drawer menu -->
  <div id="menuDrawer" class="menu-drawer" aria-hidden="true">
    <div class="menu-drawer__header">
      <div class="menu-drawer__title">Digital Watercolors</div>
      <div class="menu-drawer__subtitle">Haslun Studio</div>
      <button id="menuCloseBtn" class="menu-drawer__close" aria-label="Close menu">âœ•</button>
    </div>

    <nav class="menu-drawer__content">
      <a class="menu-drawer__link" href="scenes/">Living Scenes</a>
      <a class="menu-drawer__link" href="gallery/">Pixel Sliders</a>
      <a class="menu-drawer__link" href="https://haslun.studio/watercolor-lab.html" target="_blank" rel="noopener">Color Lab</a>
      <a class="menu-drawer__link" href="https://haslun.studio" target="_blank" rel="noopener">Haslun.studio</a>
    </nav>
  </div>

  <!-- MOBILE: Backdrop -->
  <div id="menuBackdrop" class="menu-backdrop" hidden></div>

  <!-- Scripts -->
  <script src="watercolor-engine/watercolor-engine.js"></script>
  <script src="assets/js/loader.js"></script>
  <script src="assets/js/atmosphere.js"></script>
  <script src="assets/js/pixel-mode.js"></script>
  
  <script>
    // Image list for preloading
    const imagesToLoad = [
      'assets/img/peacocks-breathe.gif'
    ];
    
    // Initialize
    async function init() {
      // Use boot flag set by early script (prevents FOUC)
      const isPixelMode = window.__haslunBoot?.pixelMode || false;
      
      // Initialize loader with appropriate mode
      Loader.init(isPixelMode ? 'canvas' : 'dom');
      
      // Preload images
      await Loader.preloadImages(imagesToLoad);
      
      // Initialize atmosphere (subtle wash over the GIF)
      Atmosphere.init({ initialDelay: 3000 });
      
      // Initialize pixel mode toggle
      PixelMode.init();
      
      // Initialize HUD menu
      initHudMenu();
      
      // Initialize background parallax (depth effect)
      initBackgroundParallax();
      
      // Initialize mobile drawer menu
      initMobileDrawer();
    }

    // Mobile drawer menu (seal button)
    function initMobileDrawer() {
      const sealBtn = document.getElementById('sealMenuBtn');
      const drawer = document.getElementById('menuDrawer');
      const backdrop = document.getElementById('menuBackdrop');
      const closeBtn = document.getElementById('menuCloseBtn');

      if (!sealBtn || !drawer) return;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Scroll lock
      const lockScroll = () => { document.documentElement.style.overflow = 'hidden'; };
      const unlockScroll = () => { document.documentElement.style.overflow = ''; };

      function openDrawer() {
        drawer.classList.add('is-open');
        drawer.setAttribute('aria-hidden', 'false');
        sealBtn.setAttribute('aria-expanded', 'true');
        if (backdrop) backdrop.hidden = false;
        lockScroll();
      }

      function closeDrawer() {
        drawer.classList.remove('is-open');
        drawer.setAttribute('aria-hidden', 'true');
        sealBtn.setAttribute('aria-expanded', 'false');
        if (backdrop) backdrop.hidden = true;
        unlockScroll();
        resetDrawerParallax();
      }

      sealBtn.addEventListener('click', () => {
        drawer.classList.contains('is-open') ? closeDrawer() : openDrawer();
      });

      if (backdrop) backdrop.addEventListener('click', closeDrawer);
      if (closeBtn) closeBtn.addEventListener('click', closeDrawer);

      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && drawer.classList.contains('is-open')) closeDrawer();
      });

      // Micro-parallax for drawer
      function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }

      function applyDrawerParallax(xNorm, yNorm) {
        if (!drawer.classList.contains('is-open') || prefersReducedMotion) return;

        const maxRotate = 2.5;
        const maxShift = 8;

        const dx = (xNorm - 0.5) * 2;
        const dy = (yNorm - 0.5) * 2;

        const rotateY = dx * -maxRotate;
        const rotateX = dy * maxRotate;
        const translateX = dx * maxShift;
        const translateY = dy * maxShift;

        drawer.style.transform =
          `translate3d(${translateX}px, ${translateY}px, 0) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        drawer.style.setProperty('--shadow-x', `${-translateX * 0.4}px`);
        drawer.style.setProperty('--shadow-y', `${translateY * 0.8 + 10}px`);
      }

      function resetDrawerParallax() {
        drawer.style.transform = '';
        drawer.style.removeProperty('--shadow-x');
        drawer.style.removeProperty('--shadow-y');
      }

      // Pointer/touch parallax
      window.addEventListener('pointermove', (e) => {
        if (!drawer.classList.contains('is-open')) return;
        const rect = drawer.getBoundingClientRect();
        const xNorm = clamp((e.clientX - rect.left) / rect.width, 0, 1);
        const yNorm = clamp((e.clientY - rect.top) / rect.height, 0, 1);
        applyDrawerParallax(xNorm, yNorm);
      }, { passive: true });

      // Device tilt parallax (works on Android + older iOS, silently ignored on newer iOS)
      // No permission prompt â€” just listen and it works where supported
      window.addEventListener('deviceorientation', (e) => {
        if (!drawer.classList.contains('is-open') || prefersReducedMotion) return;
        if (e.gamma == null || e.beta == null) return;
        const xNorm = clamp((e.gamma + 20) / 40, 0, 1);
        const yNorm = clamp((e.beta - 20) / 40, 0, 1);
        applyDrawerParallax(xNorm, yNorm);
      }, { passive: true });
    }
    
    // HUD menu toggle (both burger + welcome trigger)
    // Production-ready: clearTimeout, rAF, aria-hidden, focus management, scroll lock
    function initHudMenu() {
      const hud = document.getElementById('hud');
      const btn = document.getElementById('hudToggle');
      const panel = document.getElementById('hudPanel');
      const welcome = document.getElementById('welcomeTrigger');

      if (!hud || !btn || !panel) return;

      let closeTimer = null;
      
      // Set initial aria state
      panel.setAttribute('aria-hidden', 'true');
      
      // Scroll lock helpers (mobile only)
      const isMobile = () => window.matchMedia('(max-width: 520px)').matches;
      const lockScroll = () => { if (isMobile()) document.documentElement.style.overflow = 'hidden'; };
      const unlockScroll = () => { document.documentElement.style.overflow = ''; };
      
      // Focus helpers
      const firstFocusable = () => panel.querySelector('a, button, [tabindex]:not([tabindex="-1"])');

      const open = () => {
        if (closeTimer) { clearTimeout(closeTimer); closeTimer = null; }

        panel.hidden = false;
        panel.setAttribute('aria-hidden', 'false');
        btn.setAttribute('aria-expanded', 'true');
        hud.classList.add('is-open');
        if (welcome) welcome.classList.add('is-hidden');
        
        lockScroll();

        // Ensure transition runs (rAF forces reflow)
        requestAnimationFrame(() => {
          panel.classList.add('open');
          // Focus first link for accessibility
          const f = firstFocusable();
          if (f) f.focus({ preventScroll: true });
        });
      };

      const close = () => {
        panel.classList.remove('open');
        panel.setAttribute('aria-hidden', 'true');
        btn.setAttribute('aria-expanded', 'false');
        hud.classList.remove('is-open');
        if (welcome) welcome.classList.remove('is-hidden');
        
        unlockScroll();
        
        // Return focus to burger
        btn.focus({ preventScroll: true });

        if (closeTimer) clearTimeout(closeTimer);
        closeTimer = setTimeout(() => {
          panel.hidden = true;
          closeTimer = null;
        }, 170);
      };

      btn.addEventListener('click', () => {
        const isOpen = btn.getAttribute('aria-expanded') === 'true';
        isOpen ? close() : open();
      });

      if (welcome) {
        welcome.addEventListener('click', open);
      }

      // Click outside closes
      document.addEventListener('pointerdown', (e) => {
        const isOpen = btn.getAttribute('aria-expanded') === 'true';
        if (!isOpen) return;
        if (panel.contains(e.target) || btn.contains(e.target)) return;
        close();
      });

      // ESC closes
      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        const isOpen = btn.getAttribute('aria-expanded') === 'true';
        if (isOpen) close();
      });
    }
    
    // Micro-parallax on background blur layer only (adds depth, stays tasteful)
    // Production-ready: running flag, touchend re-center, proper visibility handling
    function initBackgroundParallax() {
      const back = document.querySelector('.peacock-back');
      const wash = document.querySelector('.peacock-wash');
      if (!back) return;

      // Respect reduced motion
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (reduce) return;

      let tx = 0.5, ty = 0.5, cx = 0.5, cy = 0.5;
      let raf = null;
      let running = true;

      const onMove = (x, y) => {
        tx = x / window.innerWidth;
        ty = y / window.innerHeight;
      };
      
      // Re-center on touch end so background doesn't "stick"
      const recenter = () => { tx = 0.5; ty = 0.5; };

      window.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY), { passive: true });
      window.addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        onMove(t.clientX, t.clientY);
      }, { passive: true });
      window.addEventListener('touchend', recenter, { passive: true });
      window.addEventListener('touchcancel', recenter, { passive: true });

      function loop() {
        if (!running) return;
        
        cx += (tx - cx) * 0.08;
        cy += (ty - cy) * 0.08;

        const max = window.innerWidth < 520 ? 6 : 12; // subtle
        const dx = (cx - 0.5) * max;
        const dy = (cy - 0.5) * max * 0.6;

        back.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(1.08)`;
        if (wash) wash.style.transform = `translate3d(${dx * 0.4}px, ${dy * 0.4}px, 0)`;

        raf = requestAnimationFrame(loop);
      }
      loop();

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          running = false;
          if (raf) { cancelAnimationFrame(raf); raf = null; }
          return;
        }
        if (!reduce) {
          running = true;
          raf = requestAnimationFrame(loop);
        }
      });
    }
    
    init();
  </script>

</body>
</html>
